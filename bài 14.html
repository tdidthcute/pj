<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Magic Christmas - Music & Snow</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>

    <style>
      /* 1. BACKGROUND T√åNH Y√äU & TR√ÅI TIM R∆†I */
      #intro-layer {
        position: fixed;
        inset: 0;
        background: radial-gradient(
          circle,
          #ff9a9e 0%,
          #fecfef 99%,
          #fecfef 100%
        ); /* M√†u h·ªìng l√£ng m·∫°n */
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        transition: all 1s ease;
        overflow: hidden; /* Gi·ªØ tr√°i tim b√™n trong m√†n h√¨nh */
      }

      .bg-heart {
        position: absolute;
        color: rgba(255, 255, 255, 0.6);
        font-size: 20px;
        user-select: none;
        pointer-events: none;
        animation: fall linear infinite;
        z-index: 1;
      }

      @keyframes fall {
        0% {
          transform: translateY(-10vh) rotate(0deg);
          opacity: 1;
        }
        100% {
          transform: translateY(110vh) rotate(360deg);
          opacity: 0;
        }
      }
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "Segoe UI", sans-serif;
      }
      #canvas-container {
        width: 100%;
        height: 100vh;
        display: block;
      }

      /* --- PH·∫¶N B·ª®C TH∆Ø (INTRO) --- */
      #intro-layer {
        position: fixed;
        inset: 0;
        background: radial-gradient(circle, #0a192f, #000);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        transition: all 1s ease;
      }

      .envelope-container {
        position: relative;
        width: 300px;
        height: 200px;
        background-color: #f3e5ab;
        border-radius: 0 0 10px 10px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        cursor: pointer;
      }

      .flap {
        position: absolute;
        top: 0;
        left: 0;
        width: 0;
        height: 0;
        border-left: 150px solid transparent;
        border-right: 150px solid transparent;
        border-top: 110px solid #d4c38d;
        transform-origin: top;
        z-index: 3;
        transition: 0.6s ease;
      }

      .envelope-front {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #f3e5ab;
        border-radius: 0 0 10px 10px;
        z-index: 4;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        color: #b21f1f;
        text-align: center;
      }

      .letter-content {
        position: absolute;
        bottom: 10px;
        left: 10px;
        width: 280px;
        height: 180px;
        background: #fff;
        border-radius: 5px;
        z-index: 2;
        padding: 20px;
        box-sizing: border-box;
        transition: 0.8s ease;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      .envelope-container.open .flap {
        transform: rotateX(180deg);
        z-index: 1;
      }
      .envelope-container.open .letter-content {
        transform: translateY(-130px);
        z-index: 5;
        height: 220px;
      }

      #text-msg {
        font-size: 24px;
        font-weight: bold;
        color: #d32f2f;
        font-family: serif;
        text-align: center;
        font-style: italic;
      }
      .heart-btn {
        font-size: 30px;
        margin-top: 10px;
        display: none;
        animation: pulse 1.2s infinite;
      }
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }

      /* --- UI MAGIC --- */
      #ui-layer {
        position: absolute;
        bottom: 30px;
        width: 100%;
        text-align: center;
        pointer-events: none;
        z-index: 100;
        opacity: 0;
        transition: opacity 1s;
      }
      .guide {
        color: rgba(255, 255, 255, 0.6);
        font-size: 13px;
        margin-bottom: 20px;
        text-shadow: 0 2px 4px black;
      }

      #camera-preview {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 120px;
        height: 90px;
        border: 2px solid rgba(255, 0, 0, 0.5);
        border-radius: 8px;
        transform: scaleX(-1);
        opacity: 0.6;
        z-index: 50;
        display: none;
      }

      #copyright {
        position: absolute;
        bottom: 10px;
        right: 15px;
        color: rgba(255, 255, 255, 0.3);
        font-size: 12px;
        z-index: 100;
        font-style: italic;
      }
    </style>
  </head>
  <body>
    <div id="intro-layer">
      <div class="envelope-container" id="env" onclick="handleLetterClick()">
        <div class="flap"></div>
        <div class="letter-content">
          <div id="text-msg"></div>
          <div class="heart-btn" id="heart-icon">‚ù§Ô∏è</div>
        </div>
        <div class="envelope-front" id="front-text">B·∫•m ƒë·ªÉ m·ªü th∆∞ üíå</div>
      </div>
    </div>

    <div id="ui-layer">
      <div class="guide">
        üñê <b>X√≤e tay:</b> N·ªï tung &nbsp;|&nbsp; ü´∂ <b>Ch·∫°m tay:</b> Tr√°i tim
        &nbsp;|&nbsp; ‚úä <b>N·∫Øm tay:</b> C√¢y th√¥ng
      </div>
    </div>

    <div id="copyright">¬© by vandiep</div>
    <div id="canvas-container"></div>
    <video class="input_video" style="display: none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
      function createFallingHearts() {
        const intro = document.getElementById("intro-layer");
        const heartIcons = ["‚ù§Ô∏è", "üíñ", "üå∏", "‚ú®", "üíó", "üíå"];

        setInterval(() => {
          const heart = document.createElement("div");
          heart.className = "bg-heart";
          heart.innerHTML =
            heartIcons[Math.floor(Math.random() * heartIcons.length)];

          // V·ªã tr√≠ ng·∫´u nhi√™n theo chi·ªÅu ngang
          heart.style.left = Math.random() * 100 + "vw";
          // Th·ªùi gian r∆°i ng·∫´u nhi√™n t·ª´ 2s ƒë·∫øn 5s
          heart.style.animationDuration = Math.random() * 3 + 2 + "s";
          // K√≠ch th∆∞·ªõc ng·∫´u nhi√™n
          heart.style.fontSize = Math.random() * 15 + 10 + "px";

          intro.appendChild(heart);

          // X√≥a tr√°i tim sau khi r∆°i xong ƒë·ªÉ nh·∫π m√°y
          setTimeout(() => heart.remove(), 5000);
        }, 300); // C·ª© 0.3 gi√¢y t·∫°o 1 c√°i
      }

      // Ch·∫°y h√†m ngay l·∫≠p t·ª©c
      createFallingHearts();
      // --- 1. QU·∫¢N L√ù √ÇM NH·∫†C ---
      const MUSIC_URL = "./SantaTellme.mp3"; // T√™n file nh·∫°c c·ªßa b·∫°n
      let bgMusic = new Audio(MUSIC_URL);
      bgMusic.loop = true;
      bgMusic.volume = 0.6; // ƒêi·ªÅu ch·ªânh √¢m l∆∞·ª£ng (t·ª´ 0 ƒë·∫øn 1)

      // --- 2. X·ª¨ L√ù B·ª®C TH∆Ø ---
      let letterOpened = false;
      let typingDone = false;

      function handleLetterClick() {
        const env = document.getElementById("env");
        if (!letterOpened) {
          env.classList.add("open");
          letterOpened = true;

          // Ph√°t nh·∫°c ngay khi m·ªü th∆∞ (Tr√¨nh duy·ªát cho ph√©p ph√°t nh·∫°c sau khi c√≥ t∆∞∆°ng t√°c ng∆∞·ªùi d√πng)
          bgMusic
            .play()
            .catch((e) =>
              console.log("Y√™u c·∫ßu file audio.mp3 trong folder ƒë·ªÉ ph√°t nh·∫°c!")
            );

          setTimeout(startTyping, 800);
          return;
        }
        if (typingDone) {
          const intro = document.getElementById("intro-layer");
          intro.style.opacity = "0";
          setTimeout(() => {
            intro.style.display = "none";
            startSystem();
          }, 1000);
        }
      }

      function startTyping() {
        const msg = "Merry Christmas üéÑ";
        const textEl = document.getElementById("text-msg");
        let i = 0;
        function type() {
          if (i < msg.length) {
            textEl.innerHTML += msg.charAt(i);
            i++;
            setTimeout(type, 150);
          } else {
            document.getElementById("heart-icon").style.display = "block";
            typingDone = true;
            document.getElementById("front-text").innerHTML =
              "B·∫•m th√™m l·∫ßn n·ªØa ‚ú®";
          }
        }
        type();
      }

      // --- 3. HI·ªÜU ·ª®NG C√ÇY TH√îNG & TUY·∫æT R∆†I (GI·ªÆ NGUY√äN HI·ªÜU ·ª®NG) ---
      function createCustomTexture(type) {
        const canvas = document.createElement("canvas");
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext("2d");
        const cx = 64,
          cy = 64;

        if (type === "gold_glow") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
          grd.addColorStop(0, "#FFFFFF");
          grd.addColorStop(0.5, "#FFD700");
          grd.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 128, 128);
        } else if (type === "red_light") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
          grd.addColorStop(0, "#FFAAAA");
          grd.addColorStop(0.3, "#FF0000");
          grd.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 128, 128);
        } else if (type === "gift_red") {
          ctx.fillStyle = "#D32F2F";
          ctx.fillRect(20, 20, 88, 88);
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(54, 20, 20, 88);
          ctx.fillRect(20, 54, 88, 20);
        } else if (type === "snowflake") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 60);
          grd.addColorStop(0, "rgba(255,255,255,1)");
          grd.addColorStop(1, "rgba(255,255,255,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 128, 128);
        }
        return new THREE.CanvasTexture(canvas);
      }

      const textures = {
        gold: createCustomTexture("gold_glow"),
        red: createCustomTexture("red_light"),
        gift: createCustomTexture("gift_red"),
        snow: createCustomTexture("snowflake"),
      };

      const CONFIG = {
        goldCount: 2000,
        redCount: 300,
        giftCount: 150,
        snowCount: 1000,
        explodeRadius: 65,
        treeHeight: 70,
        treeBaseRadius: 35,
      };

      let scene,
        camera,
        renderer,
        groupGold,
        groupRed,
        groupGift,
        groupSnow,
        titleMesh,
        starMesh,
        loveMesh;
      let state = "TREE",
        handX = 0.5;

      function init3D() {
        const container = document.getElementById("canvas-container");
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x00050a);
        scene.fog = new THREE.FogExp2(0x00050a, 0.002);
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 100;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        groupGold = createParticleSystem("gold", CONFIG.goldCount, 2.0);
        groupRed = createParticleSystem("red", CONFIG.redCount, 3.5);
        groupGift = createParticleSystem("gift", CONFIG.giftCount, 3.0);

        // H·ªá th·ªëng tuy·∫øt
        const snowPos = [];
        for (let i = 0; i < CONFIG.snowCount; i++) {
          snowPos.push(
            (Math.random() - 0.5) * 200,
            Math.random() * 200 - 100,
            (Math.random() - 0.5) * 200
          );
        }
        const snowGeo = new THREE.BufferGeometry();
        snowGeo.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(snowPos, 3)
        );
        groupSnow = new THREE.Points(
          snowGeo,
          new THREE.PointsMaterial({
            size: 1.5,
            map: textures.snow,
            transparent: true,
            opacity: 0.6,
            depthWrite: false,
          })
        );
        scene.add(groupSnow);

        createDecorations();
        animate();
      }

      function createParticleSystem(type, count, size) {
        const pPositions = [],
          pExplodeTargets = [],
          pTreeTargets = [],
          pHeartTargets = [],
          phases = [];
        for (let i = 0; i < count; i++) {
          const h = Math.random() * CONFIG.treeHeight;
          const y = h - CONFIG.treeHeight / 2;
          let radiusRatio =
            type === "gold"
              ? Math.sqrt(Math.random())
              : 0.9 + Math.random() * 0.1;
          const r =
            (1 - h / CONFIG.treeHeight) * CONFIG.treeBaseRadius * radiusRatio;
          const theta = Math.random() * Math.PI * 2;
          pTreeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));

          const u = Math.random(),
            v = Math.random();
          const phi = Math.acos(2 * v - 1),
            lam = 2 * Math.PI * u;
          const rad =
            CONFIG.explodeRadius *
            Math.cbrt(Math.random()) *
            (type === "gift" ? 1.2 : 1.0);
          pExplodeTargets.push(
            rad * Math.sin(phi) * Math.cos(lam),
            rad * Math.sin(phi) * Math.sin(lam),
            rad * Math.foldTarget ? 0 : rad * Math.cos(phi)
          );

          const tH = Math.random() * Math.PI * 2;
          let hx = 16 * Math.pow(Math.sin(tH), 3),
            hy =
              13 * Math.cos(tH) -
              5 * Math.cos(2 * tH) -
              2 * Math.cos(3 * tH) -
              Math.cos(4 * tH);
          const rf = Math.pow(Math.random(), 0.3);
          pHeartTargets.push(
            hx * rf * 2.2,
            hy * rf * 2.2 + 5,
            (Math.random() - 0.5) * 8 * rf
          );

          pPositions.push(
            pTreeTargets[i * 3],
            pTreeTargets[i * 3 + 1],
            pTreeTargets[i * 3 + 2]
          );
          phases.push(Math.random() * Math.PI * 2);
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(pPositions, 3)
        );
        const colors = new Float32Array(count * 3);
        const baseColor = new THREE.Color(
          type === "gold" ? 0xffd700 : type === "red" ? 0xff0000 : 0xffffff
        );
        for (let i = 0; i < count * 3; i += 3) {
          colors[i] = baseColor.r;
          colors[i + 1] = baseColor.g;
          colors[i + 2] = baseColor.b;
        }
        geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        geo.userData = {
          tree: pTreeTargets,
          explode: pExplodeTargets,
          heart: pHeartTargets,
          phases: phases,
          baseColor: baseColor,
          baseSize: size,
        };
        const mat = new THREE.PointsMaterial({
          size,
          map: textures[type],
          transparent: true,
          vertexColors: true,
          blending:
            type === "gift" ? THREE.NormalBlending : THREE.AdditiveBlending,
          depthWrite: false,
          sizeAttenuation: true,
        });

        const points = new THREE.Points(geo, mat);
        scene.add(points);
        return points;
      }

      function createDecorations() {
        const canvas = document.createElement("canvas");
        canvas.width = 1024;
        canvas.height = 256;
        const ctx = canvas.getContext("2d");
        ctx.font = "bold italic 90px serif";
        ctx.fillStyle = "#FFD700";
        ctx.textAlign = "center";
        ctx.shadowColor = "#FF0000";
        ctx.shadowBlur = 40;
        ctx.fillText("MERRY CHRISTMAS", 512, 130);
        titleMesh = new THREE.Mesh(
          new THREE.PlaneGeometry(60, 15),
          new THREE.MeshBasicMaterial({
            map: new THREE.CanvasTexture(canvas),
            transparent: true,
            blending: THREE.AdditiveBlending,
          })
        );
        titleMesh.position.y = 50;
        scene.add(titleMesh);

        starMesh = new THREE.Mesh(
          new THREE.PlaneGeometry(12, 12),
          new THREE.MeshBasicMaterial({
            map: textures.gold,
            transparent: true,
            blending: THREE.AdditiveBlending,
          })
        );
        starMesh.position.y = CONFIG.treeHeight / 2 + 2;
        scene.add(starMesh);

        const lCanvas = document.createElement("canvas");
        lCanvas.width = 1024;
        lCanvas.height = 256;
        const lCtx = lCanvas.getContext("2d");
        lCtx.font = "bold 120px sans-serif";
        lCtx.fillStyle = "#FF69B4";
        lCtx.textAlign = "center";
        lCtx.shadowColor = "#FF1493";
        lCtx.shadowBlur = 40;
        lCtx.fillText("h√≠ h√≠", 512, 130);
        loveMesh = new THREE.Mesh(
          new THREE.PlaneGeometry(70, 18),
          new THREE.MeshBasicMaterial({
            map: new THREE.CanvasTexture(lCanvas),
            transparent: true,
            blending: THREE.AdditiveBlending,
          })
        );
        loveMesh.visible = false;
        scene.add(loveMesh);
      }

      function updateParticles(
        group,
        type,
        targetState,
        speed,
        handRotY,
        time
      ) {
        const pos = group.geometry.attributes.position.array;
        const col = group.geometry.attributes.color.array;
        const ud = group.geometry.userData;
        const targets = ud[targetState.toLowerCase()] || ud.explode;

        for (let i = 0; i < pos.length; i++)
          pos[i] += (targets[i] - pos[i]) * speed;
        group.geometry.attributes.position.needsUpdate = true;

        const count = pos.length / 3;
        if (targetState === "TREE") {
          group.rotation.y += 0.003;
          for (let i = 0; i < count; i++) {
            let b =
              type === "red"
                ? 0.5 + 0.5 * Math.sin(time * 3 + ud.phases[i])
                : 0.8 + 0.4 * Math.sin(time * 10 + ud.phases[i]);
            col[i * 3] = ud.baseColor.r * b;
            col[i * 3 + 1] = ud.baseColor.g * b;
            col[i * 3 + 2] = ud.baseColor.b * b;
          }
        } else if (targetState === "HEART") {
          group.rotation.y = 0;
          const s = 1 + Math.abs(Math.sin(time * 3)) * 0.15;
          group.scale.set(s, s, s);
        } else {
          group.scale.set(1, 1, 1);
          group.rotation.y += (handRotY - group.rotation.y) * 0.1;
        }
        group.geometry.attributes.color.needsUpdate = true;
      }

      function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001,
          speed = 0.08,
          handRotY = (handX - 0.5) * 4.0;
        if (groupGold)
          updateParticles(groupGold, "gold", state, speed, handRotY, time);
        if (groupRed)
          updateParticles(groupRed, "red", state, speed, handRotY, time);
        if (groupGift)
          updateParticles(groupGift, "gift", state, speed, handRotY, time);

        if (groupSnow) {
          const pos = groupSnow.geometry.attributes.position.array;
          for (let i = 1; i < pos.length; i += 3) {
            pos[i] -= 0.2;
            if (pos[i] < -100) pos[i] = 100;
          }
          groupSnow.geometry.attributes.position.needsUpdate = true;
          groupSnow.rotation.y += 0.002;
        }

        if (titleMesh) titleMesh.visible = state === "TREE";
        if (starMesh) starMesh.visible = state === "TREE";
        if (loveMesh) loveMesh.visible = state === "HEART";

        if (state === "HEART" && loveMesh) {
          const s = 1 + Math.abs(Math.sin(time * 3)) * 0.1;
          loveMesh.scale.set(s, s, 1);
        }
        if (renderer && scene && camera) renderer.render(scene, camera);
      }

      function startSystem() {
        init3D();
        document.getElementById("ui-layer").style.opacity = "1";
        const video = document.getElementsByClassName("input_video")[0];
        const canvas = document.getElementById("camera-preview");
        canvas.style.display = "block";
        const ctx = canvas.getContext("2d");
        const hands = new Hands({
          locateFile: (f) =>
            `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`,
        });
        hands.setOptions({
          maxNumHands: 2,
          modelComplexity: 1,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5,
        });
        hands.onResults((results) => {
          if (canvas.width !== results.image.width) {
            canvas.width = results.image.width;
            canvas.height = results.image.height;
          }
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
          if (results.multiHandLandmarks.length === 2) {
            const h1 = results.multiHandLandmarks[0],
              h2 = results.multiHandLandmarks[1];
            if (Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y) < 0.15) {
              state = "HEART";
              return;
            }
          }
          if (results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            handX = lm[9].x;
            let d = 0;
            [8, 12, 16, 20].forEach(
              (i) => (d += Math.hypot(lm[i].x - lm[0].x, lm[i].y - lm[0].y))
            );
            state = d / 4 < 0.25 ? "TREE" : "EXPLODE";
          } else {
            state = "TREE";
          }
        });
        new Camera(video, {
          onFrame: async () => {
            await hands.send({ image: video });
          },
          width: 640,
          height: 480,
        }).start();
      }

      window.addEventListener("resize", () => {
        if (camera) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });
    </script>
  </body>
</html>
